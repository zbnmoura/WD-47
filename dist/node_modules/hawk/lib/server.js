'use strict';// Load modules const Boom = require('boom');const Hoek = require('hoek');const Cryptiles = require('cryptiles');const Crypto = require('./crypto');const Utils = require('./utils');//;// Hawk authentication exports.authenticate = function(req,credentialsFunc,options,callback){callback = Hoek.nextTick(callback);// Default options options.nonceFunc = options.nonceFunc || internals.nonceFunc;options.timestampSkewSec = options.timestampSkewSec || 60;// 60 seconds // Application time const now = Utils.now(options.localtimeOffsetMsec);// Measure now before any other processing // Convert node Http request object to a request configuration object const request = Utils.parseRequest(req,options);if(request instanceof Error){return callback(Boom.badRequest(request.message))}// Parse HTTP Authorization header const attributes = Utils.parseAuthorizationHeader(request.authorization);if(attributes instanceof Error){return callback(attributes)}// Construct artifacts container const artifacts ={method:request.method,host:request.host,port:request.port,resource:request.url,ts:attributes.ts,nonce:attributes.nonce,hash:attributes.hash,ext:attributes.ext,app:attributes.app,dlg:attributes.dlg,mac:attributes.mac,id:attributes.id};// Verify required header attributes if(!attributes.id ||!attributes.ts ||!attributes.nonce ||!attributes.mac){return callback(Boom.badRequest('Missing attributes'),null,artifacts)}// Fetch Hawk credentials credentialsFunc(attributes.id,(err,credentials) =>{if(err){return callback(err,credentials || null,artifacts)}if(!credentials){return callback(Utils.unauthorized('Unknown credentials'),null,artifacts)}if(!credentials.key ||!credentials.algorithm){return callback(Boom.internal('Invalid credentials'),credentials,artifacts)}if(Crypto.algorithms.indexOf(credentials.algorithm) === -1){return callback(Boom.internal('Unknown algorithm'),credentials,artifacts)}// calculate MAC const mac = Crypto.calculateMac('header',credentials,artifacts);if(!Cryptiles.fixedTimeComparison(mac,attributes.mac)){return callback(Utils.unauthorized('Bad mac'),credentials,artifacts)}// Check payload hash if(options.payload || options.payload === ''){if(!attributes.hash){return callback(Utils.unauthorized('Missing required payload hash'),credentials,artifacts)}const hash = Crypto.calculatePayloadHash(options.payload,credentials.algorithm,request.contentType);if(!Cryptiles.fixedTimeComparison(hash,attributes.hash)){return callback(Utils.unauthorized('Bad payload hash'),credentials,artifacts)}}// Check nonce options.nonceFunc(credentials.key,attributes.nonce,attributes.ts,(err) =>{if(err){return callback(Utils.unauthorized('Invalid nonce'),credentials,artifacts)}// Check timestamp staleness if(Math.abs((attributes.ts * 1000) - now)>(options.timestampSkewSec * 1000)){const tsm = Crypto.timestampMessage(credentials,options.localtimeOffsetMsec);return callback(Utils.unauthorized('Stale timestamp',tsm),credentials,artifacts)}// Successful authentication return callback(null,credentials,artifacts)})})};// Authenticate payload hash - used when payload cannot be provided during authenticate() exports.authenticatePayload = function(payload,credentials,artifacts,contentType){const calculatedHash = Crypto.calculatePayloadHash(payload,credentials.algorithm,contentType);return Cryptiles.fixedTimeComparison(calculatedHash,artifacts.hash)};// Authenticate payload hash - used when payload cannot be provided during authenticate() exports.authenticatePayloadHash = function(calculatedHash,artifacts){return Cryptiles.fixedTimeComparison(calculatedHash,artifacts.hash)};// Generate a Server-Authorization header for a given response exports.header = function(credentials,artifacts,options){//;if(!artifacts || typeof artifacts!== 'object' || typeof options!== 'object'){return ''}artifacts = Hoek.clone(artifacts);delete artifacts.mac;artifacts.hash = options.hash;artifacts.ext = options.ext;// Validate credentials if(!credentials ||!credentials.key ||!credentials.algorithm){// Invalid credential object return ''}if(Crypto.algorithms.indexOf(credentials.algorithm) === -1){return ''}// calculate payload hash if(!artifacts.hash &&(options.payload || options.payload === '')){artifacts.hash = Crypto.calculatePayloadHash(options.payload,credentials.algorithm,options.contentType)}const mac = Crypto.calculateMac('response',credentials,artifacts);// Construct header let header = 'Hawk mac="'+mac+'"'+(artifacts.hash ? ', hash="'+artifacts.hash+'"' :'');if(artifacts.ext!== null && artifacts.ext!== undefined && artifacts.ext!== ''){// Other falsey values allowed header = header+', ext="'+Hoek.escapeHeaderAttribute(artifacts.ext)+'"'}return header};// 1 2 3 4 internals.bewitRegex = /^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/;exports.authenticateBewit = function(req,credentialsFunc,options,callback){callback = Hoek.nextTick(callback);// Application time const now = Utils.now(options.localtimeOffsetMsec);// Convert node Http request object to a request configuration object const request = Utils.parseRequest(req,options);if(request instanceof Error){return callback(Boom.badRequest(request.message))}// Extract bewit if(request.url.length>Utils.limits.maxMatchLength){return callback(Boom.badRequest('Resource path exceeds max length'))}const resource = request.url.match(internals.bewitRegex);if(!resource){return callback(Utils.unauthorized())}// Bewit not empty if(!resource[3]){return callback(Utils.unauthorized('Empty bewit'))}// Verify method is GET if(request.method!== 'GET' && request.method!== 'HEAD'){return callback(Utils.unauthorized('Invalid method'))}// No other authentication if(request.authorization){return callback(Boom.badRequest('Multiple authentications'))}// Parse bewit const bewitString = Hoek.base64urlDecode(resource[3]);if(bewitString instanceof Error){return callback(Boom.badRequest('Invalid bewit encoding'))}// Bewit format:id\exp\mac\ext('\' is used because it is a reserved header attribute character)

    const bewitParts = bewitString.split('\\');
    if (bewitParts.length !== 4) {
        return callback(Boom.badRequest('Invalid bewit structure'));
    }

    const bewit = {
        id: bewitParts[0],
        exp: parseInt(bewitParts[1], 10),
        mac: bewitParts[2],
        ext: bewitParts[3] || ''
    };

    if (!bewit.id ||
        !bewit.exp ||
        !bewit.mac) {

        return callback(Boom.badRequest('Missing bewit attributes'));
    }

    // Construct URL without bewit

    let url = resource[1];
    if (resource[4]) {
        url = url + resource[2] + resource[4];
    }

    // Check expiration

    if (bewit.exp * 1000 <= now) {
        return callback(Utils.unauthorized('Access expired'), null, bewit);
    }

    // Fetch Hawk credentials

    credentialsFunc(bewit.id, (err, credentials) => {

        if (err) {
            return callback(err, credentials || null, bewit.ext);
        }

        if (!credentials) {
            return callback(Utils.unauthorized('Unknown credentials'), null, bewit);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
        }

        // Calculate MAC

        const mac = Crypto.calculateMac('bewit', credentials, {
            ts: bewit.exp,
            nonce: '',
            method: 'GET',
            resource: url,
            host: request.host,
            port: request.port,
            ext: bewit.ext
        });

        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
            return callback(Utils.unauthorized('Bad mac'), credentials, bewit);
        }

        // Successful authentication

        return callback(null, credentials, bewit);
    });
};


/*
 *  options are the same as authenticate() with the exception that the only supported options are:
 * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
 */

exports.authenticateMessage = function (host, port, message, authorization, credentialsFunc, options, callback) {

    callback = Hoek.nextTick(callback);

    // Default options

    options.nonceFunc = options.nonceFunc || internals.nonceFunc;
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    const now = Utils.now(options.localtimeOffsetMsec);                       // Measure now before any other processing

    // Validate authorization

    if (!authorization.id ||
        !authorization.ts ||
        !authorization.nonce ||
        !authorization.hash ||
        !authorization.mac) {

        return callback(Boom.badRequest('Invalid authorization'));
    }

    // Fetch Hawk credentials

    credentialsFunc(authorization.id, (err, credentials) => {

        if (err) {
            return callback(err, credentials || null);
        }

        if (!credentials) {
            return callback(Utils.unauthorized('Unknown credentials'));
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials);
        }

        // Construct artifacts container

        const artifacts = {
            ts: authorization.ts,
            nonce: authorization.nonce,
            host,
            port,
            hash: authorization.hash
        };

        // Calculate MAC

        const mac = Crypto.calculateMac('message', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, authorization.mac)) {
            return callback(Utils.unauthorized('Bad mac'), credentials);
        }

        // Check payload hash

        const hash = Crypto.calculatePayloadHash(message, credentials.algorithm);
        if (!Cryptiles.fixedTimeComparison(hash, authorization.hash)) {
            return callback(Utils.unauthorized('Bad message hash'), credentials);
        }

        // Check nonce

        options.nonceFunc(credentials.key, authorization.nonce, authorization.ts, (err) => {

            if (err) {
                return callback(Utils.unauthorized('Invalid nonce'), credentials);
            }

            // Check timestamp staleness

            if (Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                return callback(Utils.unauthorized('Stale timestamp'),credentials)}// Successful authentication return callback(null,credentials)})})};internals.nonceFunc = function(key,nonce,ts,nonceCallback){return nonceCallback();// No validation};