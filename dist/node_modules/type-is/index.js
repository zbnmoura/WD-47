/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */'use strict' var typer = require('media-typer') var mime = require('mime-types') module.exports = typeofrequest module.exports.is = typeis module.exports.hasBody = hasbody module.exports.normalize = normalize module.exports.match = mimeMatch function typeis(value,types_){var i var types = types_ // remove parameters and normalize var val = tryNormalizeType(value) // no type or invalid if(!val){return false}// support flattened arguments if(types &&!Array.isArray(types)){types = new Array(arguments.length - 1) for(i = 0;i < types.length;i++){types[i] = arguments[i+1]}}// no types,return the content type if(!types ||!types.length){return val}var type for(i = 0;i < types.length;i++){if(mimeMatch(normalize(type = types[i]),val)){return type[0] === '+' || type.indexOf('*')!== -1 ? val:type}}// no matches return false}function hasbody(req){return req.headers['transfer-encoding']!== undefined ||!isNaN(req.headers['content-length'])}function typeofrequest(req,types_){var types = types_ // no body if(!hasbody(req)){return null}// support flattened arguments if(arguments.length>2){types = new Array(arguments.length - 1) for(var i = 0;i < types.length;i++){types[i] = arguments[i+1]}}// request content type var value = req.headers['content-type'] return typeis(value,types)}function normalize(type){if(typeof type!== 'string'){// invalid type return false}switch(type){case 'urlencoded':return 'application/x-www-form-urlencoded' case 'multipart':return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '* function mimeMatch(expected,actual){// invalid type if(expected === false){return false}// split types var actualParts = actual.split('/') var expectedParts = expected.split('/') // invalid format if(actualParts.length!== 2 || expectedParts.length!== 2){return false}// validate type if(expectedParts[0]!== '*' && expectedParts[0]!== actualParts[0]){return false}// validate suffix wildcard if(expectedParts[1].substr(0,2) === '*+'){return expectedParts[1].length <= actualParts[1].length+1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)}// validate subtype if(expectedParts[1]!== '*' && expectedParts[1]!== actualParts[1]){return false}return true}function normalizeType(value){// parse the type var type = typer.parse(value) // remove the parameters type.parameters = undefined // reformat it return typer.format(type)}function tryNormalizeType(value){try{return normalizeType(value)}catch(err){return null}}