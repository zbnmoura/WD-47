'use strict';var util = require('util');var union = require('arr-union');var define = require('define-property');var staticExtend = require('static-extend');var isObj = require('isobject');var cu = module.exports;cu.isObject = function isObject(val){return isObj(val) || typeof val === 'function'};cu.has = function has(obj,val){val = cu.arrayify(val);var len = val.length;if(cu.isObject(obj)){for(var key in obj){if(val.indexOf(key)>-1){return true}}var keys = cu.nativeKeys(obj);return cu.has(keys,val)}if(Array.isArray(obj)){var arr = obj;while(len--){if(arr.indexOf(val[len])>-1){return true}}return false}throw new TypeError('expected an array or object.')};cu.hasAll = function hasAll(val,values){values = cu.arrayify(values);var len = values.length;while(len--){if(!cu.has(val,values[len])){return false}}return true};cu.arrayify = function arrayify(val){return val ?(Array.isArray(val) ? val:[val]):[]};cu.noop = function noop(){return};cu.identity = function identity(val){return val};cu.hasConstructor = function hasConstructor(val){return cu.isObject(val) && typeof val.constructor!== 'undefined'};cu.nativeKeys = function nativeKeys(val){if(!cu.hasConstructor(val)) return [];var keys = Object.getOwnPropertyNames(val);if('caller' in val) keys.push('caller');return keys};cu.getDescriptor = function getDescriptor(obj,key){if(!cu.isObject(obj)){throw new TypeError('expected an object.')}if(typeof key!== 'string'){throw new TypeError('expected key to be a string.')}return Object.getOwnPropertyDescriptor(obj,key)};cu.copyDescriptor = function copyDescriptor(receiver,provider,name){if(!cu.isObject(receiver)){throw new TypeError('expected receiving object to be an object.')}if(!cu.isObject(provider)){throw new TypeError('expected providing object to be an object.')}if(typeof name!== 'string'){throw new TypeError('expected name to be a string.')}var val = cu.getDescriptor(provider,name);if(val) Object.defineProperty(receiver,name,val)};cu.copy = function copy(receiver,provider,omit){if(!cu.isObject(receiver)){throw new TypeError('expected receiving object to be an object.')}if(!cu.isObject(provider)){throw new TypeError('expected providing object to be an object.')}var props = Object.getOwnPropertyNames(provider);var keys = Object.keys(provider);var len = props.length,key;omit = cu.arrayify(omit);while(len--){key = props[len];if(cu.has(keys,key)){define(receiver,key,provider[key])}else if(!(key in receiver) &&!cu.has(omit,key)){cu.copyDescriptor(receiver,provider,key)}}};cu.inherit = function inherit(receiver,provider,omit){if(!cu.isObject(receiver)){throw new TypeError('expected receiving object to be an object.')}if(!cu.isObject(provider)){throw new TypeError('expected providing object to be an object.')}var keys = [];for(var key in provider){keys.push(key);receiver[key] = provider[key]}keys = keys.concat(cu.arrayify(omit));var a = provider.prototype || provider;var b = receiver.prototype || receiver;cu.copy(b,a,keys)};cu.extend = function(){// keep it lazy,instead of assigning to `cu.extend` return staticExtend.apply(null,arguments)};cu.bubble = function(Parent,events){events = events || [];Parent.bubble = function(Child,arr){if(Array.isArray(arr)){events = union([],events,arr)}var len = events.length;var idx = -1;while(++idx < len){var name = events[idx];Parent.on(name,Child.emit.bind(Child,name))}cu.bubble(Child,events)}};