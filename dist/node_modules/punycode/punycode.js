/*! https://mths.be/punycode v1.4.1 by @mathias */;(function(root){var freeExports = typeof exports == 'object' && exports &&!exports.nodeType && exports;var freeModule = typeof module == 'object' && module &&!module.nodeType && module;var freeGlobal = typeof global == 'object' && global;if(freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal){root = freeGlobal}var punycode,maxInt = 2147483647,// aka. 0x7FFFFFFF or 2^31-1 base = 36,tMin = 1,tMax = 26,skew = 38,damp = 700,initialBias = 72,initialN = 128,// 0x80 delimiter = '-',// '\x2D' regexPunycode = /^xn--/,regexNonASCII = /[^\x20-\x7E]/,// unprintable ASCII chars+non-ASCII chars regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators errors ={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},baseMinusTMin = base - tMin,floor = Math.floor,stringFromCharCode = String.fromCharCode,key;function error(type){throw new RangeError(errors[type])}function map(array,fn){var length = array.length;var result = [];while(length--){result[length] = fn(array[length])}return result}function mapDomain(string,fn){var parts = string.split('@');var result = '';if(parts.length>1){// In email addresses,only the domain name should be punycoded. Leave // the local part(i.e. everything up to `@`) intact. result = parts[0]+'@';string = parts[1]}// Avoid `split(regex)` for IE8 compatibility. See #17. string = string.replace(regexSeparators,'\x2E');var labels = string.split('.');var encoded = map(labels,fn).join('.');return result+encoded}function ucs2decode(string){var output = [],counter = 0,length = string.length,value,extra;while(counter < length){value = string.charCodeAt(counter++);if(value>= 0xD800 && value <= 0xDBFF && counter < length){// high surrogate,and there is a next character extra = string.charCodeAt(counter++);if((extra & 0xFC00) == 0xDC00){// low surrogate output.push(((value & 0x3FF) << 10)+(extra & 0x3FF)+0x10000)}else{// unmatched surrogate;only append this code unit,in case the next // code unit is the high surrogate of a surrogate pair output.push(value);counter--}}else{output.push(value)}}return output}function ucs2encode(array){return map(array,function(value){var output = '';if(value>0xFFFF){value -= 0x10000;output+= stringFromCharCode(value>>>10 & 0x3FF | 0xD800);value = 0xDC00 | value & 0x3FF}output+= stringFromCharCode(value);return output}).join('')}function basicToDigit(codePoint){if(codePoint - 48 < 10){return codePoint - 22}if(codePoint - 65 < 26){return codePoint - 65}if(codePoint - 97 < 26){return codePoint - 97}return base}function digitToBasic(digit,flag){// 0..25 map to ASCII a..z or A..Z // 26..35 map to ASCII 0..9 return digit+22+75 *(digit < 26) -((flag!= 0) << 5)}function adapt(delta,numPoints,firstTime){var k = 0;delta = firstTime ? floor(delta / damp):delta>>1;delta+= floor(delta / numPoints);for(;delta>baseMinusTMin * tMax>>1;k+= base){delta = floor(delta / baseMinusTMin)}return floor(k+(baseMinusTMin+1) * delta /(delta+skew))}function decode(input){// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point if(input.charCodeAt(j)>= 0x80){error('not-basic')}output.push(input.charCodeAt(j))}// Main decoding loop:start just after the last delimiter if any basic code // points were copied;start at the beginning otherwise. for(index = basic>0 ? basic+1 :0;index < inputLength;){// `index` is the index of the next character to be consumed. // Decode a generalized variable-length integer into `delta`,// which gets added to `i`. The overflow checking is easier // if we increase `i` as we go,then subtract off its starting // value at the end to obtain `delta`. for(oldi = i,w = 1,k = base;k+= base){if(index>= inputLength){error('invalid-input')}digit = basicToDigit(input.charCodeAt(index++));if(digit>= base || digit>floor((maxInt - i) / w)){error('overflow')}i+= digit * w;t = k <= bias ? tMin :(k>= bias+tMax ? tMax :k - bias);if(digit < t){break}baseMinusT = base - t;if(w>floor(maxInt / baseMinusT)){error('overflow')}w *= baseMinusT}out = output.length+1;bias = adapt(i - oldi,out,oldi == 0);// `i` was supposed to wrap around from `out` to `0`,// incrementing `n` each time,so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i>state to <m,0>,// but guard against overflow handledCPCountPlusOne = handledCPCount+1;if(m - n>floor((maxInt - delta) / handledCPCountPlusOne)){error('overflow')}delta+=(m - n) * handledCPCountPlusOne;n = m;for(j = 0;j < inputLength;++j){currentValue = input[j];if(currentValue < n &&++delta>maxInt){error('overflow')}if(currentValue == n){// Represent delta as a generalized variable-length integer for(q = delta,k = base;k+= base){t = k <= bias ? tMin:(k>= bias+tMax ? tMax:k - bias);if(q < t){break}qMinusT = q - t;baseMinusT = base - t;output.push(stringFromCharCode(digitToBasic(t+qMinusT % baseMinusT,0)));q = floor(qMinusT / baseMinusT)}output.push(stringFromCharCode(digitToBasic(q,0)));bias = adapt(delta,handledCPCountPlusOne,handledCPCount == basicLength);delta = 0;++handledCPCount}}++delta;++n}return output.join('')}function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()):string})}function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string) ? 'xn--'+encode(string):string})}punycode ={'version':'1.4.1','ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};// Some AMD build optimizers,like r.js,check for specific condition patterns // like the following:if(typeof define == 'function' && typeof define.amd == 'object' && define.amd){define('punycode',function(){return punycode})}else if(freeExports && freeModule){if(module.exports == freeExports){// in Node.js,io.js,or RingoJS v0.8.0+freeModule.exports = punycode}else{// in Narwhal or RingoJS v0.7.0- for(key in punycode){punycode.hasOwnProperty(key) &&(freeExports[key] = punycode[key])}}}else{// in Rhino or a web browser root.punycode = punycode}}(this));