(function(){var undefined;var VERSION = "4.17.4";var LARGE_ARRAY_SIZE = 200;var FUNC_ERROR_TEXT = "Expected a function";var HASH_UNDEFINED = "__lodash_hash_undefined__";var max_MEMOIZE_SIZE = 500;var CLONE_DEEP_FLAG = 1,CLONE_FLAT_FLAG = 2,CLONE_SYMBOLS_FLAG = 4;var COMPARE_PARTIAL_FLAG = 1,COMPARE_UNORDERED_FLAG = 2;var HOT_COUNT = 800,HOT_SPAN = 16;var INFINITY = 1 / 0,max_SAFE_INTEGER = 9007199254740991,max_INTEGER = 1.7976931348623157e308,NAN = 0 / 0;var argsTag = "[object Arguments]",arrayTag = "[object Array]",asyncTag = "[object AsyncFunction]",boolTag = "[object Boolean]",dateTag = "[object Date]",errorTag = "[object Error]",funcTag = "[object Function]",genTag = "[object GeneratorFunction]",mapTag = "[object Map]",numberTag = "[object Number]",nullTag = "[object Null]",objectTag = "[object Object]",promiseTag = "[object Promise]",proxyTag = "[object Proxy]",regexpTag = "[object RegExp]",setTag = "[object Set]",stringTag = "[object String]",symbolTag = "[object Symbol]",undefinedTag = "[object Undefined]",weakMapTag = "[object WeakMap]";var arrayBufferTag = "[object ArrayBuffer]",dataViewTag = "[object DataView]",float32Tag = "[object Float32Array]",float64Tag = "[object Float64Array]",int8Tag = "[object Int8Array]",int16Tag = "[object Int16Array]",int32Tag = "[object Int32Array]",uint8Tag = "[object Uint8Array]",uint8ClampedTag = "[object Uint8ClampedArray]",uint16Tag = "[object Uint16Array]",uint32Tag = "[object Uint32Array]";var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;
    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to compose unicode character classes. */
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    /** Used to compose unicode capture groups. */
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" +
        rsZWJ +
        "(?:" +
        [rsNonAstral, rsRegional, rsSurrPair].join("|") +
        ")" +
        rsOptVar +
        reOptMod +
        ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" +
        [
            rsNonAstral + rsCombo + "?",
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral
        ].join("|") +
        ")";
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == "object" &&
        global &&
        global.Object === Object &&
        global;
    /** Detect free variable `self`. */
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function("return this")();
    /** Detect free variable `exports`. */
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule = freeExports &&
        typeof module == "object" &&
        module &&
        !module.nodeType &&
        module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function () {
        try {
            return (freeProcess &&
                freeProcess.binding &&
                freeProcess.binding("util"));
        }
        catch (e) { }
    })();
    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /*--------------------------------------------------------------------------*/
    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */
    function addMapEntry(map, pair) {
        // Don't return `map.set` because it's not chainable in IE 11.
        map.set(pair[0], pair[1]);
        return map;
    }
    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */
    function addSetEntry(set, value) {
        // Don't return `set.add` because it's not chainable in IE 11.
        set.add(value);
        return set;
    }
    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
        switch (args.length) {
            case 0:
                return func.call(thisArg);
            case 1:
                return func.call(thisArg, args[0]);
            case 2:
                return func.call(thisArg, args[0], args[1]);
            case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }
    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }
    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
    }
    /**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (comparator(value, array[index])) {
                return true;
            }
        }
        return false;
    }
    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
            result[index] = iteratee(array[index], index, array);
        }
        return result;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
        return string.split("");
    }
    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }
    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
        return value === value
            ? strictIndexOf(array, value, fromIndex)
            : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
        return value !== value;
    }
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
        return function (object) {
            return object == null ? undefined : object[key];
        };
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }
    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
        return arrayMap(props, function (key) {
            return object[key];
        });
    }
    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
        return cache.has(key);
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
        return object == null ? undefined : object[key];
    }
    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
            result.push(data.value);
        }
        return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
        return function (arg) {
            return func(transform(arg));
        };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }
    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
        return hasUnicode(string)
            ? unicodeToArray(string)
            : asciiToArray(string);
    }
    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    /*--------------------------------------------------------------------------*/
    /** Used for built-in method references. */
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */
    var coreJsData = root["__core-js_shared__"];
    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || "");
        return uid ? "Symbol(src)_1." + uid : "";
    })();
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;
    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);
    /** Used to detect if a method is native. */
    var reIsNative = RegExp("^" +
        funcToString
            .call(hasOwnProperty)
            .replace(reRegExpChar, "\\___PRESERVED_TOKEN_37___")
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
        "$");
    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
    var defineProperty = (function () {
        try {
            var func = getNative(Object, "defineProperty");
            func({}, "", {});
            return func;
        }
        catch (e) { }
    })();
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeNow = Date.now;
    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    /** Used to lookup unminified function names. */
    var realNames = {};
    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash() {
        // No operation performed.
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function () {
        function object() { }
        return function (proto) {
            if (!isObject(proto)) {
                return {};
            }
            if (objectCreate) {
                return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
        };
    })();
    /*------------------------------------------------------------------------*/
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate
            ? data[key] !== undefined
            : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] =
            nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        return this;
    }
    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /*------------------------------------------------------------------------*/
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        }
        else {
            splice.call(data, index, 1);
        }
        --this.size;
        return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            ++this.size;
            data.push([key, value]);
        }
        else {
            data[index][1] = value;
        }
        return this;
    }
    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash()
        };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
    }
    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /*------------------------------------------------------------------------*/
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
            this.add(values[index]);
        }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
        return this.__data__.has(value);
    }
    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
        var data = (this.__data__ = new ListCache(entries));
        this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
        return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
        return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }
    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /*------------------------------------------------------------------------*/
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes &&
                    // Safari 9 has enumerable `arguments.length` in strict mode.
                    (key == "length" ||
                        // Node.js 0.10 has enumerable non-index properties on buffers.
                        (isBuff && (key == "offset" || key == "parent")) ||
                        // PhantomJS 2 has enumerable non-index properties on typed arrays.
                        (isType &&
                            (key == "buffer" ||
                                key == "byteLength" ||
                                key == "byteOffset")) ||
                        // Skip index properties.
                        isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }
    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
        if ((value !== undefined && !eq(object[key], value)) ||
            (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
        }
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
        }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
    }
    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
    }
    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
            });
        }
        else {
            object[key] = value;
        }
    }
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
            result = object
                ? customizer(value, key, object, stack)
                : customizer(value);
        }
        if (result !== undefined) {
            return result;
        }
        if (!isObject(value)) {
            return value;
        }
        var isArr = isArray(value);
        if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
                return copyArray(value, result);
            }
        }
        else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                    return isFlat
                        ? copySymbolsIn(value, baseAssignIn(result, value))
                        : copySymbols(value, baseAssign(result, value));
                }
            }
            else {
                if (!cloneableTags[tag]) {
                    return object ? value : {};
                }
                result = initCloneByTag(value, tag, baseClone, isDeep);
            }
        }
        // Check for circular references and return its corresponding clone.
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
            return stacked;
        }
        stack.set(value, result);
        var keysFunc = isFull
            ? isFlat ? getAllKeysIn : getAllKeys
            : isFlat ? keysIn : keys;
        var props = isArr ? undefined : keysFunc(value);
        arrayEach(props || value, function (subValue, key) {
            if (props) {
                key = subValue;
                subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
        return result;
    }
    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);
    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                    // Recursively flatten arrays (susceptible to call stack limits).
                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                }
                else {
                    arrayPush(result, value);
                }
            }
            else if (!isStrict) {
                result[result.length] = value;
            }
        }
        return result;
    }
    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();
    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
    }
    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
            object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object)
            ? result
            : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value)
            ? getRawTag(value)
            : objectToString(value);
    }
    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
        return object != null && key in Object(object);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
            return true;
        }
        if (value == null ||
            other == null ||
            (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
                return false;
            }
            objIsArr = true;
            objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object)
                ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
        }
        if (!isSameTag) {
            return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
            return !length;
        }
        object = Object(object);
        while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2]
                ? data[1] !== object[data[0]]
                : !(data[0] in object)) {
                return false;
            }
        }
        while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                    return false;
                }
            }
            else {
                var stack = new Stack();
                if (customizer) {
                    var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === undefined
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
        return (isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]);
    }
    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
        // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9. // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details. if(typeof value == "function"){return value}if(value == null){return identity}if(typeof value == "object"){return isArray(value) ? baseMatchesProperty(value[0],value[1]):baseMatches(value)}return property(value)}function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object)}var result = [];for(var key in Object(object)){if(hasOwnProperty.call(object,key) && key!= "constructor"){result.push(key)}}return result}function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object)}var isProto = isPrototype(object),result = [];for(var key in object){if(!(key == "constructor" &&(isProto ||!hasOwnProperty.call(object,key)))){result.push(key)}}return result}function baseMatches(source){var matchData = getMatchData(source);if(matchData.length == 1 && matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1])}return function(object){return object === source || baseIsMatch(object,source,matchData)}}function baseMatchesProperty(path,srcValue){if(isKey(path) && isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue)}return function(object){var objValue = get(object,path);return objValue === undefined && objValue === srcValue ? hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)}}function baseMerge(object,source,srcIndex,customizer,stack){if(object === source){return}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack ||(stack = new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack)}else{var newValue = customizer ? customizer(object[key],srcValue,key+"",object,source,stack):undefined;if(newValue === undefined){newValue = srcValue}assignMergeValue(object,key,newValue)}},keysIn)}function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue = object[key],srcValue = source[key],stacked = stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return}var newValue = customizer ? customizer(objValue,srcValue,key+"",object,source,stack) :undefined;var isCommon = newValue === undefined;if(isCommon){var isArr = isArray(srcValue),isBuff =!isArr && isBuffer(srcValue),isTyped =!isArr &&!isBuff && isTypedArray(srcValue);newValue = srcValue;if(isArr || isBuff || isTyped){if(isArray(objValue)){newValue = objValue}else if(isArrayLikeObject(objValue)){newValue = copyArray(objValue)}else if(isBuff){isCommon = false;newValue = cloneBuffer(srcValue,true)}else if(isTyped){isCommon = false;newValue = cloneTypedArray(srcValue,true)}else{newValue = []}}else if(isPlainObject(srcValue) || isArguments(srcValue)){newValue = objValue;if(isArguments(objValue)){newValue = toPlainObject(objValue)}else if(!isObject(objValue) ||(srcIndex && isFunction(objValue))){newValue = initCloneObject(srcValue)}}else{isCommon = false}}if(isCommon){// Recursively merge objects and arrays(susceptible to call stack limits). stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack["delete"](srcValue)}assignMergeValue(object,key,newValue)}function basePropertyDeep(path){return function(object){return baseGet(object,path)}}function baseRest(func,start){return setToString(overRest(func,start,identity),func+"")}function baseSet(object,path,value,customizer){if(!isObject(object)){return object}path = castPath(path,object);var index = -1,length = path.length,lastIndex = length - 1,nested = object;while(nested!= null &&++index < length){var key = toKey(path[index]),newValue = value;if(index!= lastIndex){var objValue = nested[key];newValue = customizer ? customizer(objValue,key,nested):undefined;if(newValue === undefined){}}assignValue(nested,key,newValue);nested = nested[key]}return object}var baseSetToString =!defineProperty ? identity :function(func,string){return defineProperty(func,"toString",{configurable:true,enumerable:false,value:constant(string),writable:true})};function baseToString(value){// Exit early for strings to avoid a performance hit in some environments. if(typeof value == "string"){return value}if(isArray(value)){// Recursively convert values(susceptible to call stack limits). return arrayMap(value,baseToString)+""}if(isSymbol(value)){return symbolToString ? symbolToString.call(value):""}var result = value+"";return result == "0" && 1 / value == -INFINITY ? "-0" :result}function baseUniq(array,iteratee,comparator){var index = -1,includes = arrayIncludes,length = array.length,isCommon = true,result = [],seen = result;if(comparator){isCommon = false;includes = arrayIncludesWith}else if(length>= LARGE_ARRAY_SIZE){var set = iteratee ? null:createSet(array);if(set){return setToArray(set)}isCommon = false;includes = cacheHas;seen = new SetCache()}else{seen = iteratee ? []:result}outer:while(++index < length){var value = array[index],computed = iteratee ? iteratee(value):value;value = comparator || value!== 0 ? value:0;if(isCommon && computed === computed){var seenIndex = seen.length;while(seenIndex--){if(seen[seenIndex] === computed){continue outer}}if(iteratee){seen.push(computed)}result.push(value)}else if(!includes(seen,computed,comparator)){if(seen!== result){seen.push(computed)}result.push(value)}}return result}function castPath(value,object){if(isArray(value)){return value}return isKey(value,object) ? [value] :stringToPath(toString(value))}function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice()}var length = buffer.length,result = allocUnsafe ? allocUnsafe(length) :new buffer.constructor(length);buffer.copy(result);return result}function cloneArrayBuffer(arrayBuffer){var result = new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result}function cloneDataView(dataView,isDeep){var buffer = isDeep ? cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength)}function cloneMap(map,isDeep,cloneFunc){var array = isDeep ? cloneFunc(mapToArray(map),CLONE_DEEP_FLAG):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor())}function cloneRegExp(regexp){var result = new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex = regexp.lastIndex;return result}function cloneSet(set,isDeep,cloneFunc){var array = isDeep ? cloneFunc(setToArray(set),CLONE_DEEP_FLAG):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor())}function cloneSymbol(symbol){}function cloneTypedArray(typedArray,isDeep){var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length)}function copyArray(source,array){var index = -1,length = source.length;array ||(array = Array(length));while(++index < length){array[index] = source[index]}return array}function copyObject(source,props,object,customizer){var isNew =!object;);var index = -1,length = props.length;while(++index < length){var key = props[index];var newValue = customizer ? customizer(object[key],source[key],key,object,source):undefined;if(newValue === undefined){newValue = source[key]}if(isNew){baseAssignValue(object,key,newValue)}else{assignValue(object,key,newValue)}}return object}function copySymbols(source,object){return copyObject(source,getSymbols(source),object)}function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object)}function createAssigner(assigner){return baseRest(function(object,sources){var index = -1,length = sources.length,customizer = length>1 ? sources[length - 1]:undefined,guard = length>2 ? sources[2]:undefined;customizer = assigner.length>3 && typeof customizer == "function" ?(length--,customizer):undefined;if(guard && isIterateeCall(sources[0],sources[1],guard)){customizer = length < 3 ? undefined:customizer;length = 1}object = Object(object);while(++index < length){var source = sources[index];if(source){assigner(object,source,index,customizer)}}return object})}function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection == null){return collection}if(!isArrayLike(collection)){return eachFunc(collection,iteratee)}var length = collection.length,index = fromRight ? length :-1,iterable = Object(collection);while(fromRight ? index-- :++index < length){if(iteratee(iterable[index],index,iterable) === false){break}}return collection}}function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index = -1,iterable = Object(object),props = keysFunc(object),length = props.length;while(length--){var key = props[fromRight ? length:++index];if(iteratee(iterable[key],key,iterable) === false){break}}return object}}var createSet =!(Set && 1 / setToArray(new Set([,-0]))[1] == INFINITY) ? noop :function(values){return new Set(values)};function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial = bitmask & COMPARE_PARTIAL_FLAG,arrLength = array.length,othLength = other.length;if(arrLength!= othLength &&!(isPartial && othLength>arrLength)){return false}// Assume cyclic values are equal. var stacked = stack.get(array);if(stacked && stack.get(other)){return stacked == other}var index = -1,result = true,seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() :undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties. while(++index < arrLength){var arrValue = array[index],othValue = other[index];if(customizer){var compared = isPartial ? customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack)}if(compared!== undefined){if(compared){continue}result = false;break}// Recursively compare arrays(susceptible to call stack limits). if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex) &&(arrValue === othValue || equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex)}})){result = false;break}}else if(!(arrValue === othValue || equalFunc(arrValue,othValue,bitmask,customizer,stack))){result = false;break}}stack["delete"](array);stack["delete"](other);return result}function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!= other.byteLength || object.byteOffset!= other.byteOffset){return false}object = object.buffer;other = other.buffer;case arrayBufferTag:if(object.byteLength!= other.byteLength ||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds. // Invalid dates are coerced to `NaN`. return eq(+object,+other);case errorTag:return(object.name == other.name && object.message == other.message);case regexpTag:case stringTag:// Coerce regexes to strings and treat strings,primitives and objects,// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring // for more details. return object == other+"";case mapTag:var convert = mapToArray;case setTag:var isPartial = bitmask & COMPARE_PARTIAL_FLAG;convert ||(convert = setToArray);if(object.size!= other.size &&!isPartial){return false}// Assume cyclic values are equal. var stacked = stack.get(object);if(stacked){return stacked == other}bitmask |= COMPARE_UNORDERED_FLAG;// Recursively compare objects(susceptible to call stack limits). stack.set(object,other);var result = equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack["delete"](object);return result;case symbolTag:if(symbolValueOf){return(symbolValueOf.call(object) == symbolValueOf.call(other))}}return false}function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial = bitmask & COMPARE_PARTIAL_FLAG,objProps = getAllKeys(object),objLength = objProps.length,othProps = getAllKeys(other),othLength = othProps.length;if(objLength!= othLength &&!isPartial){return false}var index = objLength;while(index--){var key = objProps[index];if(!(isPartial ? key in other:hasOwnProperty.call(other,key))){return false}}// Assume cyclic values are equal. var stacked = stack.get(object);if(stacked && stack.get(other)){return stacked == other}var result = true;stack.set(object,other);stack.set(other,object);var skipCtor = isPartial;while(++index < objLength){key = objProps[index];var objValue = object[key],othValue = other[key];if(customizer){var compared = isPartial ? customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack)}// Recursively compare objects(susceptible to call stack limits). if(!(compared === undefined ? objValue === othValue || equalFunc(objValue,othValue,bitmask,customizer,stack) :compared)){result = false;break}skipCtor ||(skipCtor = key == "constructor")}if(result &&!skipCtor){var objCtor = object.constructor,othCtor = other.constructor;// Non `Object` object instances with different constructors are not equal. if(objCtor!= othCtor &&("constructor" in object && "constructor" in other) &&!(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)){result = false}}stack["delete"](object);stack["delete"](other);return result}function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols)}function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn)}function getIteratee(){var result = lodash.iteratee || iteratee;result = result === iteratee ? baseIteratee:result;return arguments.length ? result(arguments[0],arguments[1]):result}function getMapData(map,key){var data = map.__data__;return isKeyable(key) ? data[typeof key == "string" ? "string":"hash"]:data.map}function getMatchData(object){var result = keys(object),length = result.length;while(length--){var key = result[length],value = object[key];result[length] = [key,value,isStrictComparable(value)]}return result}function getNative(object,key){var value = getValue(object,key);return baseIsNative(value) ? value:undefined}function getRawTag(value){var isOwn = hasOwnProperty.call(value,symToStringTag),tag = value[symToStringTag];try{value[symToStringTag] = undefined;var unmasked = true}var result = nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag] = tag}else{delete value[symToStringTag]}}return result}var getSymbols =!nativeGetSymbols ? stubArray :function(object){if(object == null){return []}object = Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol)})};var getSymbolsIn =!nativeGetSymbols ? stubArray :function(object){var result = [];while(object){arrayPush(result,getSymbols(object));object = getPrototype(object)}return result};var getTag = baseGetTag;// Fallback for data views,maps,sets,and weak maps in IE 11 and promises in Node.js < 6. if((DataView && getTag(new DataView(new ArrayBuffer(1)))!= dataViewTag) ||(Map && getTag(new Map())!= mapTag) ||(Promise && getTag(Promise.resolve())!= promiseTag) ||(Set && getTag(new Set())!= setTag) ||(WeakMap && getTag(new WeakMap())!= weakMapTag)){getTag = function(value){var result = baseGetTag(value),Ctor = result == objectTag ? value.constructor:undefined,ctorString = Ctor ? toSource(Ctor):"";if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag}}return result}}function hasPath(object,path,hasFunc){path = castPath(path,object);var index = -1,length = path.length,result = false;while(++index < length){var key = toKey(path[index]);if(!(result = object!= null && hasFunc(object,key))){break}object = object[key]}if(result ||++index!= length){return result}length = object == null ? 0 :object.length;return(!!length && isLength(length) && isIndex(key,length) &&(isArray(object) || isArguments(object)))}function initCloneArray(array){var length = array.length,result = array.constructor(length);// Add properties assigned by `RegExp#exec`. if(length && typeof array[0] == "string" && hasOwnProperty.call(array,"index")){result.index = array.index;result.input = array.input}return result}function initCloneObject(object){}function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor = object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object)}}function isFlattenable(value){return(isArray(value) || isArguments(value) ||!!(spreadableSymbol && value && value[spreadableSymbol]))}function isIndex(value,length){length = length == null ? max_SAFE_INTEGER:length;return(!!length &&(typeof value == "number" || reIsUint.test(value)) &&(value>-1 && value % 1 == 0 && value < length))}function isIterateeCall(value,index,object){if(!isObject(object)){return false}var type = typeof index;if(type == "number" ? isArrayLike(object) && isIndex(index,object.length) :type == "string" && index in object){return eq(object[index],value)}return false}function isKey(value,object){if(isArray(value)){return false}var type = typeof value;if(type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)){return true}return(reIsPlainProp.test(value) ||!reIsDeepProp.test(value) ||(object!= null && value in Object(object)))}function isKeyable(value){var type = typeof value;return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value!== "__proto__":value === null}function isMasked(func){return!!maskSrcKey && maskSrcKey in func}function isPrototype(value){var Ctor = value && value.constructor,proto =(typeof Ctor == "function" && Ctor.prototype) || objectProto;return value === proto}function isStrictComparable(value){return value === value &&!isObject(value)}function matchesStrictComparable(key,srcValue){return function(object){if(object == null){return false}return(object[key] === srcValue &&(srcValue!== undefined || key in Object(object)))}}function memoizeCapped(func){var result = memoize(func,function(key){if(cache.size === max_MEMOIZE_SIZE){cache.clear()}return key});var cache = result.cache;return result}function nativeKeysIn(object){var result = [];if(object!= null){for(var key in Object(object)){result.push(key)}}return result}function objectToString(value){return nativeObjectToString.call(value)}function overRest(func,start,transform){start = nativeMax(start === undefined ? func.length - 1:start,0);return function(){var args = arguments,index = -1,length = nativeMax(args.length - start,0),array = Array(length);while(++index < length){array[index] = args[start+index]}index = -1;var otherArgs = Array(start+1);while(++index < start){otherArgs[index] = args[index]}otherArgs[start] = transform(array);return apply(func,this,otherArgs)}}var setToString = shortOut(baseSetToString);function shortOut(func){var count = 0,lastCalled = 0;return function(){var stamp = nativeNow(),remaining = HOT_SPAN -(stamp - lastCalled);lastCalled = stamp;if(remaining>0){if(++count>= HOT_COUNT){return arguments[0]}}else{count = 0}return func.apply(undefined,arguments)}}var stringToPath = memoizeCapped(function(string){var result = [];if(reLeadingDot.test(string)){result.push("")}string.replace(rePropName,function(match,number,quote,string){result.push(quote ? string.replace(reEscapeChar,"$1"):number || match)});return result});function toKey(value){if(typeof value == "string" || isSymbol(value)){return value}var result = value+"";return result == "0" && 1 / value == -INFINITY ? "-0" :result}function toSource(func){if(func!= null){try{return funcToString.call(func)}try{return func+""}}return ""}var union = baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true))});function forEach(collection,iteratee){var func = isArray(collection) ? arrayEach:baseEach;return func(collection,getIteratee(iteratee,3))}function includes(collection,value,fromIndex,guard){collection = isArrayLike(collection) ? collection:values(collection);fromIndex = fromIndex &&!guard ? toInteger(fromIndex):0;var length = collection.length;if(fromIndex < 0){fromIndex = nativeMax(length+fromIndex,0)}return isString(collection) ? fromIndex <= length && collection.indexOf(value,fromIndex)>-1 :!!length && baseIndexOf(collection,value,fromIndex)>-1}function memoize(func,resolver){if(typeof func!= "function" ||(resolver!= null && typeof resolver!= "function")){throw new TypeError(FUNC_ERROR_TEXT)}var memoized = function(){var args = arguments,key = resolver ? resolver.apply(this,args):args[0],cache = memoized.cache;if(cache.has(key)){return cache.get(key)}var result = func.apply(this,args);memoized.cache = cache.set(key,result) || cache;return result};memoized.cache = new(memoize.Cache || MapCache)();return memoized}// Expose `MapCache`. memoize.Cache = MapCache;function eq(value,other){return value === other ||(value!== value && other!== other)}var isArguments = baseIsArguments((function(){return arguments})()) ? baseIsArguments :function(value){return(isObjectLike(value) && hasOwnProperty.call(value,"callee") &&!propertyIsEnumerable.call(value,"callee"))};var isArray = Array.isArray;function isArrayLike(value){return value!= null && isLength(value.length) &&!isFunction(value)}function isArrayLikeObject(value){return isObjectLike(value) && isArrayLike(value)}var isBuffer = nativeIsBuffer || stubFalse;function isFunction(value){if(!isObject(value)){return false}// The use of `Object#toString` avoids issues with the `typeof` operator // in Safari 9 which returns 'object' for typed arrays and other constructors. var tag = baseGetTag(value);return(tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag)}function isLength(value){return(typeof value == "number" && value>-1 && value % 1 == 0 && value <= max_SAFE_INTEGER)}function isObject(value){var type = typeof value;return value!= null &&(type == "object" || type == "function")}function isObjectLike(value){return value!= null && typeof value == "object"}function isPlainObject(value){if(!isObjectLike(value) || baseGetTag(value)!= objectTag){return false}var proto = getPrototype(value);if(proto === null){return true}var Ctor = hasOwnProperty.call(proto,"constructor") && proto.constructor;return(typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString)}function isString(value){return(typeof value == "string" ||(!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag))}function isSymbol(value){return(typeof value == "symbol" ||(isObjectLike(value) && baseGetTag(value) == symbolTag))}var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) :baseIsTypedArray;function isUndefined(value){return value === undefined}function toArray(value){if(!value){return []}if(isArrayLike(value)){return isString(value) ? stringToArray(value):copyArray(value)}if(symIterator && value[symIterator]){return iteratorToArray(value[symIterator]())}var tag = getTag(value),func = tag == mapTag ? mapToArray :tag == setTag ? setToArray :values;return func(value)}function toFinite(value){if(!value){return value === 0 ? value:0}value = toNumber(value);if(value === INFINITY || value === -INFINITY){var sign = value < 0 ? -1:1;return sign * max_INTEGER}return value === value ? value :0}function toInteger(value){var result = toFinite(value),remainder = result % 1;return result === result ? remainder ? result - remainder:result:0}function toNumber(value){if(typeof value == "number"){return value}if(isSymbol(value)){return NAN}if(isObject(value)){var other = typeof value.valueOf == "function" ? value.valueOf():value;value = isObject(other) ? other+"":other}if(typeof value!= "string"){return value === 0 ? value:+value}value = value.replace(reTrim,"");var isBinary = reIsBinary.test(value);return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2),isBinary ? 2 :8) :reIsBadHex.test(value) ? NAN :+value}function toPlainObject(value){return copyObject(value,keysIn(value))}function toString(value){return value == null ? "":baseToString(value)}function get(object,path,defaultValue){var result = object == null ? undefined:baseGet(object,path);return result === undefined ? defaultValue:result}function hasIn(object,path){return object!= null && hasPath(object,path,baseHasIn)}function keys(object){return isArrayLike(object) ? arrayLikeKeys(object):baseKeys(object)}function keysIn(object){return isArrayLike(object) ? arrayLikeKeys(object,true):baseKeysIn(object)}var merge = createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex)});function set(object,path,value){return object == null ? object:baseSet(object,path,value)}function values(object){return object == null ? []:baseValues(object,keys(object))}function constant(value){return function(){return value}}function identity(value){return value}function iteratee(func){return baseIteratee(typeof func == "function" ? func:baseClone(func,CLONE_DEEP_FLAG))}function noop(){// No operation performed.}function property(path){return isKey(path) ? baseProperty(toKey(path)):basePropertyDeep(path)}function stubArray(){return []}function stubFalse(){return false}// Add methods that return wrapped values in chain sequences. lodash.constant = constant;lodash.iteratee = iteratee;lodash.keys = keys;lodash.keysIn = keysIn;lodash.memoize = memoize;lodash.merge = merge;lodash.property = property;lodash.set = set;lodash.toArray = toArray;lodash.toPlainObject = toPlainObject;lodash.union = union;lodash.values = values;// Add methods that return unwrapped values in chain sequences. lodash.eq = eq;lodash.forEach = forEach;lodash.get = get;lodash.hasIn = hasIn;lodash.identity = identity;lodash.includes = includes;lodash.isArguments = isArguments;lodash.isArray = isArray;lodash.isArrayLike = isArrayLike;lodash.isArrayLikeObject = isArrayLikeObject;lodash.isBuffer = isBuffer;lodash.isFunction = isFunction;lodash.isLength = isLength;lodash.isObject = isObject;lodash.isObjectLike = isObjectLike;lodash.isPlainObject = isPlainObject;lodash.isString = isString;lodash.isSymbol = isSymbol;lodash.isTypedArray = isTypedArray;lodash.isUndefined = isUndefined;lodash.stubArray = stubArray;lodash.stubFalse = stubFalse;lodash.noop = noop;lodash.toFinite = toFinite;lodash.toInteger = toInteger;lodash.toNumber = toNumber;lodash.toString = toString;// Add aliases. lodash.each = forEach;lodash.VERSION = VERSION;if(freeModule){// Export for Node.js.(freeModule.exports = lodash)._ = lodash;// Export for CommonJS support. freeExports._ = lodash}}.call(this));//# sourceMappingURL=lodash.custom.js.map