var isArray = require('isarray');var isBuf = require('./is-buffer');var toString = Object.prototype.toString;var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';exports.deconstructPacket = function(packet){var buffers = [];var packetData = packet.data;var pack = packet;pack.data = _deconstructPacket(packetData,buffers);pack.attachments = buffers.length;// number of binary 'attachments' return{packet:pack,buffers:buffers}};function _deconstructPacket(data,buffers){if(!data) return data;if(isBuf(data)){var placeholder ={_placeholder:true,num:buffers.length};buffers.push(data);return placeholder}else if(isArray(data)){var newData = new Array(data.length);for(var i = 0;i < data.length;i++){newData[i] = _deconstructPacket(data[i],buffers)}return newData}else if(typeof data === 'object' &&!(data instanceof Date)){;for(var key in data){newData[key] = _deconstructPacket(data[key],buffers)}return newData}return data}exports.reconstructPacket = function(packet,buffers){packet.data = _reconstructPacket(packet.data,buffers);packet.attachments = undefined;// no longer useful return packet};function _reconstructPacket(data,buffers){if(!data) return data;if(data && data._placeholder){return buffers[data.num];// appropriate buffer(should be natural order anyway)}else if(isArray(data)){for(var i = 0;i < data.length;i++){data[i] = _reconstructPacket(data[i],buffers)}}else if(typeof data === 'object'){for(var key in data){data[key] = _reconstructPacket(data[key],buffers)}}return data}exports.removeBlobs = function(data,callback){function _removeBlobs(obj,curKey,containingObject){if(!obj) return obj;// convert any blob if((withNativeBlob && obj instanceof Blob) ||(withNativeFile && obj instanceof File)){pendingBlobs++;// async filereader var fileReader = new FileReader();fileReader.onload = function(){// this.result == arraybuffer if(containingObject){containingObject[curKey] = this.result}else{bloblessData = this.result}// if nothing pending its callback time if(!--pendingBlobs){callback(bloblessData)}};fileReader.readAsArrayBuffer(obj);// blob ->arraybuffer}else if(isArray(obj)){// handle array for(var i = 0;i < obj.length;i++){_removeBlobs(obj[i],i,obj)}}else if(typeof obj === 'object' &&!isBuf(obj)){// and object for(var key in obj){_removeBlobs(obj[key],key,obj)}}}var pendingBlobs = 0;var bloblessData = data;_removeBlobs(bloblessData);if(!pendingBlobs){callback(bloblessData)}};